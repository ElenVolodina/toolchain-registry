--- a/include/clang/Format/Format.h
+++ b/include/clang/Format/Format.h
@@ -1425,6 +1425,9 @@ struct FormatStyle {
     /// \endcode
     ///
     bool SplitEmptyNamespace;
+
+    bool AfterConstructorInitializers;
+    bool AfterInheritanceList;
   };
 
   /// Control of individual brace wrapping cases.
@@ -3378,6 +3381,8 @@ struct FormatStyle {
   /// \version 14
   PackConstructorInitializersStyle PackConstructorInitializers;
 
+  bool AlwaysBreakBeforeMultipleInheritanceList;
+
   /// The penalty for breaking around an assignment operator.
   /// \version 5
   unsigned PenaltyBreakAssignment;

--- a/lib/Format/Format.cpp
+++ b/lib/Format/Format.cpp
@@ -214,6 +214,8 @@ template <> struct MappingTraits<FormatStyle::BraceWrappingFlags> {
     IO.mapOptional("SplitEmptyFunction", Wrapping.SplitEmptyFunction);
     IO.mapOptional("SplitEmptyRecord", Wrapping.SplitEmptyRecord);
     IO.mapOptional("SplitEmptyNamespace", Wrapping.SplitEmptyNamespace);
+    IO.mapOptional("AfterConstructorInitializers", Wrapping.AfterConstructorInitializers);
+    IO.mapOptional("AfterInheritanceList", Wrapping.AfterInheritanceList);
   }
 };
 
@@ -1032,6 +1034,7 @@ template <> struct MappingTraits<FormatStyle> {
                    Style.ObjCSpaceBeforeProtocolList);
     IO.mapOptional("PackConstructorInitializers",
                    Style.PackConstructorInitializers);
+    IO.mapOptional("AlwaysBreakBeforeMultipleInheritanceList", Style.AlwaysBreakBeforeMultipleInheritanceList);
     IO.mapOptional("PenaltyBreakAssignment", Style.PenaltyBreakAssignment);
     IO.mapOptional("PenaltyBreakBeforeFirstCallParameter",
                    Style.PenaltyBreakBeforeFirstCallParameter);
@@ -1293,7 +1296,9 @@ static void expandPresetsBraceWrapping(FormatStyle &Expanded) {
                             /*IndentBraces=*/false,
                             /*SplitEmptyFunction=*/true,
                             /*SplitEmptyRecord=*/true,
-                            /*SplitEmptyNamespace=*/true};
+                            /*SplitEmptyNamespace=*/true,
+                            /*AfterConstructorInitializers=*/false,
+                            /*AfterInheritanceList=*/false};
   switch (Expanded.BreakBeforeBraces) {
   case FormatStyle::BS_Linux:
     Expanded.BraceWrapping.AfterClass = true;
@@ -1363,7 +1368,9 @@ static void expandPresetsBraceWrapping(FormatStyle &Expanded) {
         /*IndentBraces=*/true,
         /*SplitEmptyFunction=*/true,
         /*SplitEmptyRecord=*/true,
-        /*SplitEmptyNamespace=*/true};
+        /*SplitEmptyNamespace=*/true,
+        /*AfterConstructorInitializers=*/false,
+        /*AfterInheritanceList=*/false};
     break;
   case FormatStyle::BS_WebKit:
     Expanded.BraceWrapping.AfterFunction = true;
@@ -1464,7 +1471,9 @@ FormatStyle getLLVMStyle(FormatStyle::LanguageKind Language) {
                              /*IndentBraces=*/false,
                              /*SplitEmptyFunction=*/true,
                              /*SplitEmptyRecord=*/true,
-                             /*SplitEmptyNamespace=*/true};
+                             /*SplitEmptyNamespace=*/true,
+                             /*AfterConstructorInitializers=*/false,
+                             /*AfterInheritanceList=*/false};
   LLVMStyle.BreakAdjacentStringLiterals = true;
   LLVMStyle.BreakAfterAttributes = FormatStyle::ABS_Leave;
   LLVMStyle.BreakAfterJavaFieldAnnotations = false;
@@ -1597,6 +1606,8 @@ FormatStyle getLLVMStyle(FormatStyle::LanguageKind Language) {
   LLVMStyle.ContextIndependentContinuationIndent = false;
   LLVMStyle.AllowMultilineLambdaCaptureList = false;
 
+  LLVMStyle.AlwaysBreakBeforeMultipleInheritanceList = false;
+
   // Defaults that differ when not C++.
   switch (Language) {
   case FormatStyle::LK_TableGen:

--- a/lib/Format/TokenAnnotator.cpp
+++ b/lib/Format/TokenAnnotator.cpp
@@ -3491,6 +3491,9 @@ void TokenAnnotator::calculateFormattingInformation(AnnotatedLine &Line) const {
   FormatToken *ClosingParen = nullptr;
   FormatToken *AfterLastAttribute = nullptr;
 
+  bool SeenMultipleInheritanceList = false;
+  bool SeenConstructorInitializers = false;
+
   for (auto *Tok = Current; Tok; Tok = Tok->Next) {
     if (Tok->is(TT_StartOfName))
       SeenName = true;
@@ -3613,6 +3616,18 @@ void TokenAnnotator::calculateFormattingInformation(AnnotatedLine &Line) const {
       Current->SpacesRequiredBefore = 1;
     }
 
+    if (Current->is(TT_CtorInitializerColon)) {
+      SeenConstructorInitializers = true;
+    }
+    if (Current->is(TT_InheritanceColon)) {
+      for (const auto *Tok = First; Tok && !Tok->isOneOf(TT_ClassLBrace, TT_StructLBrace); Tok = Tok->Next) {
+        if (Tok->is(TT_InheritanceComma)) {
+          SeenMultipleInheritanceList = true;
+          break;
+        }
+      }
+    }
+
     const auto &Children = Prev->Children;
     if (!Children.empty() && Children.back()->Last->is(TT_LineComment)) {
       Current->MustBreakBefore = true;
@@ -3625,6 +3640,21 @@ void TokenAnnotator::calculateFormattingInformation(AnnotatedLine &Line) const {
       }
     }
 
+    if (Style.BraceWrapping.AfterConstructorInitializers &&
+        SeenConstructorInitializers && Current->is(TT_FunctionLBrace)) {
+      Current->MustBreakBefore = true;
+    }
+    if (Style.BraceWrapping.AfterInheritanceList &&
+        SeenMultipleInheritanceList && Current->isOneOf(TT_ClassLBrace, TT_StructLBrace)) {
+      Current->MustBreakBefore = true;
+    }
+
+    if (Style.AlwaysBreakBeforeMultipleInheritanceList &&
+        SeenMultipleInheritanceList &&
+        Current->is(TT_InheritanceColon)) {
+      Current->MustBreakBefore = true;
+    }
+
     Current->CanBreakBefore =
         Current->MustBreakBefore || canBreakBefore(Line, *Current);
     unsigned ChildSize = 0;
